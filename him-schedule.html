<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>L·ªãch C·ªßa Anh</title>
    <link rel="stylesheet" href="css/global.css">
    <link rel="stylesheet" href="css/schedule.css">
    <link rel="stylesheet" href="css/sunset-theme.css">
    <link rel="stylesheet" href="css/notifications.css">
    <link rel="icon" type="image/png" href="./images/logo.svg">
    <style>
        .schedule-container::after {
            content: '' !important;
            position: absolute !important;
            top: 0 !important;
            left: 0 !important;
            right: 0 !important;
            bottom: 0 !important;
            background-image: url('./images/xe.jpg') !important;
            background-size: 200px 200px !important;
            background-repeat: repeat !important;
            background-position: 0 0 !important;
            opacity: 0.08 !important;
            z-index: 1 !important;
            pointer-events: none !important;
        }
        
        .schedule-container:hover::after {
            opacity: 0.08 !important;
            transform: none !important;
        }
        
        /* Debug modal styles */
        #event-modal {
            display: none !important;
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0, 0, 0, 0.5) !important;
            z-index: 999999 !important;
            justify-content: center !important;
            align-items: center !important;
            opacity: 1 !important;
            visibility: visible !important;
            margin: 0 !important;
            padding: 0 !important;
            pointer-events: auto !important;
        }
        
        #event-modal[style*="flex"] {
            display: flex !important;
            opacity: 1 !important;
            visibility: visible !important;
        }
        
        /* Force modal content to be visible */
        #event-modal .modal-content {
            opacity: 1 !important;
            visibility: visible !important;
            transform: none !important;
            position: relative !important;
            z-index: 1000000 !important;
            background: white !important;
            padding: 20px !important;
            border-radius: 10px !important;
            max-width: 500px !important;
            width: 90% !important;
            margin: auto !important;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
            pointer-events: auto !important;
        }
        
        /* Force all modal elements to be visible */
        #event-modal * {
            opacity: 1 !important;
            visibility: visible !important;
        }
    </style>
</head>
<body>
    <!-- Floating Hearts Animation -->
    <div class="floating-hearts" id="floating-hearts"></div>
    
    <div class="schedule-container">
        <a href="him-dashboard.html" id="back-to-dashboard-btn" class="back-to-dashboard-btn">‚Ü© Quay l·∫°i</a>
        
        <!-- Icon decorations around container -->
        <div class="decoration-top-left"></div>
        <div class="decoration-top-right"></div>
        <div class="decoration-bottom-left"></div>
        <div class="decoration-bottom-right"></div>
        
        <h1>L·ªãch C·ªßa Anh üë®‚Äçüíª</h1>
        <div id="schedule-grid" class="schedule-grid">
        </div>
    </div>

    <div id="event-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="modal-title">Th√™m S·ª± Ki·ªán M·ªõi</h2>
            <input type="text" id="event-title-input" placeholder="T√™n s·ª± ki·ªán (VD: H·ªçp team, Deadline d·ª± √°n)">
            
            <div class="form-grid">
                <select id="event-day-select">
                    <option value="2">Th·ª© 2</option>
                    <option value="3">Th·ª© 3</option>
                    <option value="4">Th·ª© 4</option>
                    <option value="5">Th·ª© 5</option>
                    <option value="6">Th·ª© 6</option>
                    <option value="7">Th·ª© 7</option>
                    <option value="8">Ch·ªß Nh·∫≠t</option>
                </select>
                <input type="color" id="event-color-input" value="#2196F3">
                
                <input type="time" id="event-start-time-input" step="1800">
                <input type="time" id="event-end-time-input" step="1800">
            </div>

            <div class="modal-actions">
                <button id="save-event-button" class="modal-btn save">L∆∞u</button>
                <button id="delete-event-button" class="modal-btn delete">X√≥a</button>
                <button id="cancel-event-button" class="modal-btn cancel">H·ªßy</button>
            </div>
        </div>
    </div>

    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.6.7/firebase-firestore-compat.js"></script>

    <script src="js/firebase-init.js"></script>
    <script src="js/notifications.js"></script>
    <script src="js/realtime-sync.js"></script>
    <script src="js/navigation.js"></script>
    <script src="js/smooth-scroll.js"></script>
    <script src="js/schedule.js"></script>
    <script src="js/floating-hearts.js"></script>

    <script>
        // His Schedule Management (using Firebase like schedule.html)
        let events = [];
        let currentEditingEvent = null;

        // Override runSchedulePage to use hisData instead of herData
        const originalRunSchedulePage = window.runSchedulePage;
        
        window.runSchedulePage = function(data) {
            console.log("üéØ runSchedulePage called with data:", data);
            
            // Use hisData instead of herData
            const scheduleGrid = document.getElementById('schedule-grid');
            if (!scheduleGrid) {
                console.error("‚ùå schedule-grid element not found!");
                return;
            }
            console.log("‚úÖ schedule-grid found");

            const scheduleData = data.schedule || [];
            events = scheduleData;
            console.log("üìÖ Schedule data:", scheduleData);

            // T·ª± ƒë·ªông ki·ªÉm tra k√≠ch th∆∞·ªõc m√†n h√¨nh ƒë·ªÉ ch·ªçn giao di·ªán ph√π h·ª£p
            if (window.innerWidth <= 768) {
                console.log("üì± Mobile view - using renderMobileSchedule");
                // N·∫øu l√† m√†n h√¨nh nh·ªè (iPhone), v·∫Ω giao di·ªán di ƒë·ªông
                if (typeof renderMobileSchedule === 'function') {
                    renderMobileSchedule(scheduleData, scheduleGrid);
                } else {
                    console.error("‚ùå renderMobileSchedule function not found!");
                }
            } else {
                console.log("üñ•Ô∏è Desktop view - using grid layout");
                // N·∫øu l√† m√†n h√¨nh l·ªõn, v·∫Ω giao di·ªán l∆∞·ªõi nh∆∞ c≈©
                if (typeof drawScheduleGrid === 'function') {
                    drawScheduleGrid(scheduleGrid);
                    console.log("‚úÖ Grid drawn");
                } else {
                    console.error("‚ùå drawScheduleGrid function not found!");
                }
                
                if (typeof renderEvents === 'function') {
                    renderEvents(scheduleData, scheduleGrid);
                    console.log("‚úÖ Events rendered");
                } else {
                    console.error("‚ùå renderEvents function not found!");
                }
                
                // Use our custom click listener instead of schedule.js
                setupCustomGridClickListener(scheduleGrid);
                console.log("‚úÖ Custom click listeners setup");
            }
        };
        
        // Custom grid click listener for his schedule
        function setupCustomGridClickListener(gridElement) {
            if (!gridElement) return;
            
            // Remove existing listeners
            gridElement.replaceWith(gridElement.cloneNode(true));
            const newGrid = document.getElementById('schedule-grid');
            
            let clickDebounce = null;
            
            newGrid.addEventListener('click', (e) => {
                // Prevent rapid clicks
                if (clickDebounce) {
                    console.log("‚ö†Ô∏è Click debounce active, ignoring");
                    return;
                }
                
                clickDebounce = setTimeout(() => {
                    clickDebounce = null;
                }, 300);
                
                console.log("üñ±Ô∏è Grid clicked");
                
                // Check if clicked on event item
                if (e.target.closest('.event-block')) {
                    console.log("üìÖ Event item clicked");
                    const eventBlock = e.target.closest('.event-block');
                    console.log("üîç Event block element:", eventBlock);
                    console.log("üîç Event block attributes:", eventBlock.attributes);
                    
                    // Try different ways to get event ID
                    const eventId = eventBlock.dataset.id || 
                                   eventBlock.getAttribute('data-id') || 
                                   eventBlock.id ||
                                   eventBlock.getAttribute('id');
                    
                    console.log("üîç Event ID:", eventId);
                    console.log("üîç dataset.id:", eventBlock.dataset.id);
                    console.log("üîç getAttribute('data-id'):", eventBlock.getAttribute('data-id'));
                    console.log("üîç element.id:", eventBlock.id);
                    console.log("üîç getAttribute('id'):", eventBlock.getAttribute('id'));
                    
                    // Also check all data attributes
                    console.log("üîç All data attributes:", Object.keys(eventBlock.dataset));
                    for (let key in eventBlock.dataset) {
                        console.log("üîç data-" + key + ":", eventBlock.dataset[key]);
                    }
                    
                    if (eventId) {
                        console.log("üîç Available events:", events);
                        const event = events.find(ev => ev.id === eventId);
                        console.log("üîç Found event:", event);
                        if (event) {
                            console.log("üìù Opening edit modal for event:", event.title);
                            window.openEventModal(event);
                        } else {
                            console.error("‚ùå Event not found with ID:", eventId);
                        }
                    } else {
                        console.error("‚ùå No event ID found");
                        console.log("üîç Trying to find event by position...");
                        
                        // Try to find event by position in grid
                        const gridRect = newGrid.getBoundingClientRect();
                        const x = e.clientX - gridRect.left;
                        const y = e.clientY - gridRect.top;
                        
                        console.log("üîç Click position:", { x, y });
                        
                        // Calculate which cell was clicked
                        const cellWidth = gridRect.width / 7; // 7 days
                        const cellHeight = gridRect.height / 8; // 8 time slots
                        
                        const day = Math.floor(x / cellWidth) + 1;
                        const timeSlot = Math.floor(y / cellHeight);
                        
                        console.log("üîç Calculated day:", day, "time slot:", timeSlot);
                        
                        // Find event at this position
                        const eventAtPosition = events.find(ev => {
                            const eventDay = parseInt(ev.day);
                            const eventTime = parseInt(ev.startTime.split(':')[0]);
                            
                            console.log("üîç Checking event:", ev.title, "Day:", eventDay, "Time:", eventTime);
                            console.log("üîç Against click: Day:", day, "Time slot:", timeSlot);
                            
                            // More flexible time matching
                            const timeSlots = [
                                { start: 7, end: 9 },   // 0
                                { start: 9, end: 11 },  // 1
                                { start: 11, end: 13 },  // 2
                                { start: 13, end: 15 }, // 3
                                { start: 15, end: 17 }, // 4
                                { start: 17, end: 19 },  // 5
                                { start: 19, end: 21 },  // 6
                                { start: 21, end: 23 }  // 7
                            ];
                            
                            const timeSlotRange = timeSlots[timeSlot];
                            if (!timeSlotRange) return false;
                            
                            const isInTimeSlot = eventTime >= timeSlotRange.start && eventTime < timeSlotRange.end;
                            const isCorrectDay = eventDay === day;
                            
                            console.log("üîç Time slot range:", timeSlotRange);
                            console.log("üîç Is in time slot:", isInTimeSlot);
                            console.log("üîç Is correct day:", isCorrectDay);
                            
                            return isCorrectDay && isInTimeSlot;
                        });
                        
                        if (eventAtPosition) {
                            console.log("üìù Found event by position:", eventAtPosition);
                            window.openEventModal(eventAtPosition);
                        } else {
                            console.error("‚ùå No event found at this position");
                        }
                    }
                    return;
                }
                
                // Check if clicked on empty grid cell
                if (e.target.classList.contains('grid-cell')) {
                    console.log("üìÖ Empty grid cell clicked");
                    const day = e.target.getAttribute('data-day');
                    const time = e.target.getAttribute('data-time');
                    
                    console.log("üìÖ Grid cell clicked: Day=" + day + ", Time=" + time);
                    
                    // Call our overridden openEventModal for new event
                    window.openEventModal(null, day, time);
                    return;
                }
                
                // Check if clicked on empty grid cell
                const gridRect = newGrid.getBoundingClientRect();
                const x = e.clientX - gridRect.left;
                const y = e.clientY - gridRect.top;
                
                const headerHeight = 50;
                const timeColumnWidth = 80;
                const rowHeight = 80;
                
                if (y > headerHeight && x > timeColumnWidth) {
                    const dayColumnWidth = (newGrid.offsetWidth - timeColumnWidth) / 7;
                    const dayIndex = Math.floor((x - timeColumnWidth) / dayColumnWidth);
                    const timeIndex = Math.floor((y - headerHeight) / rowHeight);
                    
                    if (dayIndex >= 0 && dayIndex < 7 && timeIndex >= 0 && timeIndex < 8) {
                        const day = dayIndex + 2; // Convert to schedule day format
                        const startHour = 7 + (timeIndex * 2);
                        const time = `${String(startHour).padStart(2, '0')}:00`;
                        
                        console.log(`üìÖ Grid cell clicked: Day=${day}, Time=${time}`);
                        
                        window.openEventModal();
                        document.getElementById('event-day-select').value = day;
                        document.getElementById('event-start-time-input').value = time;
                    }
                }
            });
        }

        // Load events from Firebase
        async function loadEvents() {
            console.log("üîç Loading events from Firebase...");
            if (typeof db === 'undefined') {
                console.error("‚ùå Firebase ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!");
                return;
            }

            try {
                const hisDataRef = db.collection('userInfo').doc('hisData');
                console.log("üì° Fetching hisData from Firebase...");
                const hisDoc = await hisDataRef.get();
                const hisData = hisDoc.exists ? hisDoc.data() : {};
                console.log("üìÑ HisData from Firebase:", hisData);
                
                events = hisData.schedule || [];
                console.log("üìÖ Events loaded:", events);
                
                // Use the same rendering logic as schedule.js
                console.log("üé® Rendering schedule...");
                window.runSchedulePage({ schedule: events });
                console.log("‚úÖ Schedule rendered");
            } catch (error) {
                console.error("‚ùå L·ªói khi t·∫£i d·ªØ li·ªáu:", error);
                events = [];
                window.runSchedulePage({ schedule: [] });
            }
        }

        // Save events to Firebase
        async function saveEvents() {
            if (typeof db === 'undefined') {
                console.error("Firebase ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!");
                return;
            }

            try {
                const hisDataRef = db.collection('userInfo').doc('hisData');
                await hisDataRef.set({
                    schedule: events
                }, { merge: true });
            } catch (error) {
                console.error("L·ªói khi l∆∞u d·ªØ li·ªáu:", error);
                alert("Kh√¥ng th·ªÉ l∆∞u d·ªØ li·ªáu!");
            }
        }

        // Override modal functions to use hisData
        const originalOpenEventModal = window.openEventModal;
        let modalDebounceTimer = null;
        
        window.openEventModal = function(event = null) {
            console.log("üéØ openEventModal called with:", event);
            console.log("üîç Call stack:", new Error().stack);
            
            const modal = document.getElementById('event-modal');
            if (!modal) {
                console.error("‚ùå event-modal not found!");
                return;
            }
            
            // Prevent multiple rapid calls
            if (modal.style.display === 'flex') {
                console.log("‚ö†Ô∏è Modal already open, ignoring call");
                return;
            }
            
            // Add debounce to prevent rapid calls
            if (modalDebounceTimer) {
                console.log("‚ö†Ô∏è Debounce active, ignoring call");
                return;
            }
            
            modalDebounceTimer = setTimeout(() => {
                modalDebounceTimer = null;
            }, 200);
            
            const title = document.getElementById('modal-title');
            const titleInput = document.getElementById('event-title-input');
            const daySelect = document.getElementById('event-day-select');
            const colorInput = document.getElementById('event-color-input');
            const startTimeInput = document.getElementById('event-start-time-input');
            const endTimeInput = document.getElementById('event-end-time-input');
            const deleteButton = document.getElementById('delete-event-button');
            
            if (event) { // Ch·∫ø ƒë·ªô S·ª≠a
                console.log("‚úèÔ∏è Edit mode");
                title.innerText = 'S·ª≠a S·ª± Ki·ªán';
                currentEditingEvent = event;
                titleInput.value = event.title;
                daySelect.value = event.day;
                colorInput.value = event.color || '#2196F3';
                startTimeInput.value = event.startTime;
                endTimeInput.value = event.endTime;
                deleteButton.style.display = 'inline-block';
            } else { // Ch·∫ø ƒë·ªô Th√™m m·ªõi
                console.log("‚ûï Add mode");
                title.innerText = 'Th√™m S·ª± Ki·ªán M·ªõi';
                currentEditingEvent = null;
                titleInput.value = '';
                colorInput.value = '#2196F3';
                startTimeInput.value = '';
                endTimeInput.value = '';
                daySelect.value = '';
                deleteButton.style.display = 'none';
            }
            
            // Move modal to body to avoid stacking context issues
            document.body.appendChild(modal);
            
            modal.style.display = 'flex';
            modal.style.zIndex = '99999';
            modal.style.position = 'fixed';
            modal.style.top = '0';
            modal.style.left = '0';
            modal.style.width = '100%';
            modal.style.height = '100%';
            modal.style.backgroundColor = 'rgba(0, 0, 0, 0.5)'; // Lighter background
            modal.style.pointerEvents = 'auto'; // Ensure modal can receive clicks
            
            console.log("‚úÖ Modal opened");
            console.log("üîç Modal computed style:", window.getComputedStyle(modal).display);
            console.log("üîç Modal visibility:", window.getComputedStyle(modal).visibility);
            console.log("üîç Modal opacity:", window.getComputedStyle(modal).opacity);
            console.log("üîç Modal z-index:", window.getComputedStyle(modal).zIndex);
            console.log("üîç Modal position:", window.getComputedStyle(modal).position);
            
            // Check modal content
            const modalContent = modal.querySelector('.modal-content');
            if (modalContent) {
                console.log("üîç Modal content found");
                console.log("üîç Modal content opacity:", window.getComputedStyle(modalContent).opacity);
                console.log("üîç Modal content visibility:", window.getComputedStyle(modalContent).visibility);
                console.log("üîç Modal content z-index:", window.getComputedStyle(modalContent).zIndex);
                console.log("üîç Modal content position:", window.getComputedStyle(modalContent).position);
                
                // Force modal content to be visible
                modalContent.style.position = 'relative';
                modalContent.style.zIndex = '100000';
                modalContent.style.backgroundColor = 'white';
                modalContent.style.padding = '20px';
                modalContent.style.borderRadius = '10px';
                modalContent.style.maxWidth = '500px';
                modalContent.style.width = '90%';
                modalContent.style.margin = 'auto';
                
                console.log("‚úÖ Modal content styles applied");
            } else {
                console.error("‚ùå Modal content not found!");
            }
            
            // Test if modal is actually visible
            setTimeout(() => {
                const rect = modal.getBoundingClientRect();
                console.log("üîç Modal bounding rect:", rect);
                console.log("üîç Modal is visible:", rect.width > 0 && rect.height > 0);
                
                // Check if modal is actually visible on screen
                const isVisible = window.getComputedStyle(modal).display !== 'none' && 
                                 window.getComputedStyle(modal).visibility !== 'hidden' &&
                                 window.getComputedStyle(modal).opacity !== '0';
                console.log("üîç Modal CSS visibility check:", isVisible);
                
                // Check stacking context
                const zIndex = window.getComputedStyle(modal).zIndex;
                console.log("üîç Modal z-index:", zIndex);
                
                // Force modal to be visible with maximum priority
                modal.style.cssText = `
                    display: flex !important;
                    position: fixed !important;
                    top: 0 !important;
                    left: 0 !important;
                    width: 100vw !important;
                    height: 100vh !important;
                    background: rgba(0, 0, 0, 0.5) !important;
                    z-index: 2147483647 !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                    margin: 0 !important;
                    padding: 0 !important;
                    pointer-events: auto !important;
                `;
                
                // Also force modal content to be on top
                const modalContent = modal.querySelector('.modal-content');
                if (modalContent) {
                    modalContent.style.cssText = `
                        position: relative !important;
                        z-index: 2147483648 !important;
                        background: white !important;
                        padding: 20px !important;
                        border-radius: 10px !important;
                        max-width: 500px !important;
                        width: 90% !important;
                        margin: auto !important;
                        box-shadow: 0 4px 20px rgba(0,0,0,0.3) !important;
                        pointer-events: auto !important;
                    `;
                }
                
                console.log("üîß Applied maximum priority styles");
                
                // Also check if there are any parent elements hiding the modal
                let parent = modal.parentElement;
                while (parent && parent !== document.body) {
                    const parentStyle = window.getComputedStyle(parent);
                    if (parentStyle.display === 'none' || parentStyle.visibility === 'hidden') {
                        console.error("‚ùå Parent element hiding modal:", parent);
                    }
                    parent = parent.parentElement;
                }
                
                // Check if modal is actually on top
                const elementsAtPoint = document.elementsFromPoint(window.innerWidth/2, window.innerHeight/2);
                console.log("üîç Elements at center of screen:", elementsAtPoint);
                const modalIndex = elementsAtPoint.indexOf(modal);
                console.log("üîç Modal position in stack:", modalIndex);
                
                if (modalIndex === -1) {
                    console.error("‚ùå Modal not found in element stack!");
                } else if (modalIndex > 0) {
                    console.warn("‚ö†Ô∏è Modal is not on top, element above:", elementsAtPoint[modalIndex - 1]);
                } else {
                    console.log("‚úÖ Modal is on top of all elements");
                }
            }, 100);
            
            // Setup button listeners after modal is opened
            setupModalButtonListeners();
            
            // Add click outside to close
            const closeModal = (e) => {
                console.log("üñ±Ô∏è Modal clicked, target:", e.target);
                if (e.target === modal) {
                    console.log("üñ±Ô∏è Click outside modal content, closing...");
                    modal.style.display = 'none';
                    currentEditingEvent = null;
                    modalDebounceTimer = null; // Reset debounce timer
                    modal.removeEventListener('click', closeModal);
                    // Remove modal from DOM to avoid stacking issues
                    if (modal.parentNode) {
                        modal.parentNode.removeChild(modal);
                    }
                } else {
                    console.log("üñ±Ô∏è Click inside modal content, keeping open");
                }
            };
            modal.addEventListener('click', closeModal);
        };


        // Setup modal button listeners
        function setupModalButtonListeners() {
            console.log("üîß Setting up modal button listeners...");
            
            const saveButton = document.getElementById('save-event-button');
            const deleteButton = document.getElementById('delete-event-button');
            const cancelButton = document.getElementById('cancel-event-button');
            
            console.log("üîç Save button found:", !!saveButton);
            console.log("üîç Delete button found:", !!deleteButton);
            console.log("üîç Cancel button found:", !!cancelButton);
            
            if (saveButton) {
                // Remove existing listeners
                saveButton.replaceWith(saveButton.cloneNode(true));
                const newSaveButton = document.getElementById('save-event-button');
                
                newSaveButton.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("üíæ Save button clicked");
                    
                    const title = document.getElementById('event-title-input').value.trim();
                    const day = document.getElementById('event-day-select').value;
                    const color = document.getElementById('event-color-input').value;
                    const startTime = document.getElementById('event-start-time-input').value;
                    const endTime = document.getElementById('event-end-time-input').value;
                    
                    console.log("üìù Form data:", { title, day, color, startTime, endTime });
                    
                    if (!title || !day || !startTime || !endTime) {
                        alert('Vui l√≤ng ƒëi·ªÅn ƒë·ªß th√¥ng tin!');
                        return;
                    }

                    const newEvent = {
                        id: currentEditingEvent?.id || Date.now().toString(),
                        title: title,
                        day: parseInt(day),
                        color: color,
                        startTime: startTime,
                        endTime: endTime,
                    };

                    console.log("üìÖ New event:", newEvent);

                    try {
                        const hisDataRef = db.collection('userInfo').doc('hisData');
                        const doc = await hisDataRef.get();
                        let schedule = doc.exists ? (doc.data().schedule || []) : [];

                        if (currentEditingEvent) { // N·∫øu l√† s·ª≠a, thay th·∫ø s·ª± ki·ªán c≈©
                            schedule = schedule.map(event => event.id === currentEditingEvent.id ? newEvent : event);
                        } else { // N·∫øu l√† th√™m m·ªõi, ƒë·∫©y v√†o m·∫£ng
                            schedule.push(newEvent);
                        }

                        console.log("üíæ Saving schedule:", schedule);
                        await hisDataRef.set({ schedule: schedule }, { merge: true });
                        
                        alert('ƒê√£ l∆∞u th√†nh c√¥ng!');
                        location.reload();
                    } catch (error) {
                        console.error("‚ùå Error saving:", error);
                        alert('L·ªói khi l∆∞u: ' + error.message);
                    }
                });
                console.log("‚úÖ Save button listener added");
            }
            
            if (deleteButton) {
                deleteButton.replaceWith(deleteButton.cloneNode(true));
                const newDeleteButton = document.getElementById('delete-event-button');
                
                newDeleteButton.addEventListener('click', async (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("üóëÔ∏è Delete button clicked");
                    
                    if (!currentEditingEvent) return;
                    
                    if (confirm('B·∫°n c√≥ ch·∫Øc ch·∫Øn mu·ªën x√≥a s·ª± ki·ªán n√†y?')) {
                        try {
                            const hisDataRef = db.collection('userInfo').doc('hisData');
                            const doc = await hisDataRef.get();
                            let schedule = doc.exists ? (doc.data().schedule || []) : [];
                            
                            schedule = schedule.filter(event => event.id !== currentEditingEvent.id);
                            await hisDataRef.set({ schedule: schedule }, { merge: true });
                            
                            alert('ƒê√£ x√≥a s·ª± ki·ªán!');
                            location.reload();
                        } catch (error) {
                            console.error("‚ùå Error deleting:", error);
                            alert('L·ªói khi x√≥a: ' + error.message);
                        }
                    }
                });
                console.log("‚úÖ Delete button listener added");
            }
            
            if (cancelButton) {
                cancelButton.replaceWith(cancelButton.cloneNode(true));
                const newCancelButton = document.getElementById('cancel-event-button');
                
                newCancelButton.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log("‚ùå Cancel button clicked");
                    document.getElementById('event-modal').style.display = 'none';
                    currentEditingEvent = null;
                    modalDebounceTimer = null; // Reset debounce timer
                    console.log("‚úÖ Modal closed via Cancel button");
                });
                console.log("‚úÖ Cancel button listener added");
            }
            
            console.log("üéâ Modal button listeners setup complete!");
        }

        // Show notification
        function showNotification(message, type = 'info') {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: ${type === 'success' ? '#28a745' : '#17a2b8'};
                color: white;
                padding: 12px 20px;
                border-radius: 5px;
                z-index: 10000;
                font-weight: 600;
                box-shadow: 0 4px 12px rgba(0,0,0,0.3);
            `;
            notification.textContent = message;
            document.body.appendChild(notification);
            
            setTimeout(() => {
                notification.remove();
            }, 3000);
        }

        // Main initialization
        document.addEventListener('DOMContentLoaded', async () => {
            console.log("üöÄ Him-schedule page loading...");
            
            // Wait for Firebase to initialize
            if (typeof db === 'undefined') {
                console.error("‚ùå Firebase ch∆∞a ƒë∆∞·ª£c kh·ªüi t·∫°o!");
                return;
            }
            console.log("‚úÖ Firebase initialized");

            // ƒê·ª£i realtime sync kh·ªüi t·∫°o
            const waitForRealtimeSync = () => {
                return new Promise((resolve) => {
                    const check = () => {
                        if (window.realtimeSync && window.realtimeSync.isInitialized) {
                            console.log("‚úÖ RealtimeSync initialized");
                            resolve();
                        } else {
                            setTimeout(check, 100);
                        }
                    };
                    check();
                });
            };

            try {
                await waitForRealtimeSync();
                
                // Load events
                console.log("üì• Loading events...");
                await loadEvents();
                console.log("‚úÖ Events loaded:", events);
                
                // Setup realtime sync for his schedule
                window.realtimeSync.listenToHisSchedule((schedule) => {
                    console.log("üîÑ Realtime update:", schedule);
                    events = schedule || [];
                    window.runSchedulePage({ schedule: events });
                });

                console.log("üéâ Him-schedule page initialized successfully!");

            } catch (error) {
                console.error("‚ùå L·ªói khi kh·ªüi t·∫°o:", error);
                alert("ƒê√£ x·∫£y ra l·ªói khi k·∫øt n·ªëi: " + error.message);
            }
        });
    </script>
</body>
</html>